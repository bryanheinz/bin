#!/usr/bin/env python3

import argparse
import logging
import pathlib
import subprocess

__VERSION__ = "2.0.0.2"

# TODO: add current stats to loop

# cursor up Terminal escape
CUP = '\x1b[1A'
# cursor clear line Terminal escape
CCL = '\x1b[2K'

class Pings:
    sent = 0
    received = 0
    # an array of result averages
    result = []
    # max avrg list size before rolling the average
    max_avrg = 1000

def arg_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', '--packets', default=20,
        help="How many packets to send.")
    parser.add_argument('-l', '--loop', action='store_true',
        help="Loops the pings until control-c is sent.")
    parser.add_argument('--log', action='store_true',
        help="Saves a persistant log to ~/Library/Logs/ping_test.log")
    parser.add_argument('--log-path', dest='log_path', type=pathlib.Path,
        help="Optional --log subcommand that overwrites the default log location.")
    parser.add_argument('-a', '--addr', default='google.com',
        help="The address to send the packets to. Can be an IP or FQDN. google.com is the default.")
    return parser.parse_args()

def main():
    print(f"Pinging {ARGS.addr}")
    
    cmd = ["ping", "-c", str(ARGS.packets), ARGS.addr]
    
    comp = subprocess.run(cmd, capture_output=True, check=False)
    out = comp.stdout.decode('utf-8')
    err = comp.stderr.decode('utf-8')
    
    if 'cannot resolve' in err:
        print("cannot resolve host")
        if ARGS.log:
            logging.info("cannot resolve host")
        return
    
    # get the ping results and split it into an array
    results_split = out.split("\n")
    
    # setup a couple of vars
    speed_split = None
    avg_speed_index = None
    
    # loop through and parse the ping result
    for r in results_split:
        if 'packets transmitted' in r:
            # this is the packets sent/recieved/% line
            packet_info = r.split(', ')
            # parse the packet info for how many were sent, recieved, success %
            for p in packet_info:
                if 'transmitted' in p:
                    packets_sent = p.split(' ')[0]
                elif 'received' in p:
                    packets_received = p.split(' ')[0]
                elif 'packet loss' in p:
                    packets_lost_percent = p.split(' ')[0]
        elif 'min/avg/max' in r:
            # this is the min/avg/max line, this parses out the average speed
            r_split = r.split(' ')
            for s in r_split:
                # split the string, find avg, get it's index position
                if 'avg' in s:
                    avg_speed_index = s.split('/').index('avg')
                elif '/' in s:
                    # this finds the actual min/avg/max numbers and splits
                    # it into an array
                    speed_split = s.split('/')
    
    # use the avg index to find the avg speed
    average_speed = "N/A"
    if speed_split and avg_speed_index:
        average_speed = speed_split[avg_speed_index]
    else:
        # couldn't get the avg index? assuming avg is array element 1
        try:
            average_speed = speed_split[1]
        except TypeError:
            print("\n***\nError getting average speed")
            print("Relavant line: {0}".format(average_speed))
            print("Setting average_speed to 'N/A'.\n***\n")
            average_speed = 'N/A'
    
    info = """\x1b[1A\x1b[2K
{0} packet loss
{1}/{2} packets received
{3} average latency
""".format(packets_lost_percent, packets_received, packets_sent, average_speed)
    
    # ! Info Dump
    print(info)
    
    if ARGS.log:
        logging.info(info)
    
    if ARGS.loop:
        # if looping, this lets us add up how many packets are sent and received
        pings.sent += int(ARGS.packets)
        pings.received += int(packets_received)
        # if looping, this appends the average speed to an array for an overall
        # average
        pings.result.append(float(average_speed))
        
        # this helps keep the average array from growing too large
        # once hitting the max_avrg, it will average the array and reset it with
        # the average up until the max_avrg was reached.
        if len(pings.result) == pings.max_avrg:
            roll_average()

# TODO: refactor roll_average into the Pings class
def roll_average():
    # get the current overall average
    average = get_average()
    # reset avrg to the current overall average
    pings.result = [average]
    # if keeping a persistant log, log this event
    if ARGS.log:
        logging.info(f"Rolling average {average}")

# TODO: refactor get_average into the Pings class
def get_average():
    # get the overall average for the avrg latency and return it
    try:
        average = sum(pings.result)/len(pings.result)
    except ZeroDivisionError:
        average = 0
    return round(average , 2)

# ! Script
ARGS = arg_parser()
pings = Pings()

# ! logging
# TODO: refactor logging
if ARGS.log:
    from datetime import datetime
    
    today = datetime.now().strftime('%Y%m%d.%H%M%S')
    lhost = ARGS.addr.replace('.', '_')
    file_name = f'ping_test.{lhost}.{today}.log'
    if ARGS.log_path:
        fn = ARGS.log_path / file_name
    else:
        log_dir = pathlib.Path(f'~/Library/Logs').expanduser()
        fn = log_dir / file_name
    
    logging.basicConfig(
        filename=fn,
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s -  %(message)s',
        datefmt='%Y-%m-%d %I:%M:%S %p'
    )
    
    print("Saving log file to {0}".format(fn))
    logging.info(f"Pinging {ARGS.addr} with {str(ARGS.packets)} packets.")

# ! Main
try:
    if ARGS.loop:
        while True:
            main()
    else:
        main()
        exit(0)
except KeyboardInterrupt:
    if not ARGS.loop: exit(0)
    print(f"{CCL}{CUP}{CCL}\r-----")
    print(f"Packet summary for {ARGS.addr}")
    # TODO: refactor into Pings
    average = get_average()
    packets_lost = pings.sent - pings.received
    # packet loss %
    # =100-(100*19/20)
    # 100-(100*packets received/packets sent)
    try:
        packet_loss_percent = round(100-(100 * pings.received / pings.sent), 2)
    except ZeroDivisionError:
        packet_loss_percent = 0
    info = """
average latency: {0}ms
total packets sent/received: {1}/{2}
packets lost: {3}
{4}% packet loss
""".format(str(average), pings.received, pings.sent, packets_lost, packet_loss_percent)
    
    print(info)
    
    if ARGS.log:
        logging.info(info)
    exit(0)
